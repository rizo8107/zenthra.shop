/**
 * Utility for interacting with Google's Gemini API using direct API calls
 */

const resolveEnv = (key: string): string | undefined => {
  if (typeof process !== 'undefined' && process?.env?.[key]) {
    return process.env[key];
  }
  try {
    return (import.meta as unknown as { env?: Record<string, string> })?.env?.[key];
  } catch {
    return undefined;
  }
};

// The API key is loaded from environment variables (Node first, then Vite-style env)
const GEMINI_API_KEY = resolveEnv('VITE_GEMINI_API_KEY') ?? '';
const API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent';

export interface ProductCopyRequest {
  name?: string;
  category?: string;
  keywords?: string;
  tone?: 'playful' | 'professional' | 'minimal' | 'luxury' | 'casual';
}

// Request/response types for Puck (page builder) AI generation
export interface PuckAiProductContext {
  id: string;
  name?: string;
  category?: string;
  price?: number;
  // tags can be string, string[], or any serialisable value â€“ we'll normalise when building the prompt
  tags?: unknown;
  description?: string;
}

export interface PuckAiRequest {
  mode: 'page' | 'section';
  description: string;
  tone?: ProductCopyRequest['tone'];
  product?: PuckAiProductContext;
}

export interface PuckAiBlock {
  type: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  props: Record<string, any>;
}

export interface PuckAiPageData {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  root?: Record<string, any>;
  content: PuckAiBlock[];
}

export interface ProductCopyResult {
  name: string;
  description: string;
  features: string; // bullet points separated by newlines
  specifications: string; // bullet points separated by newlines
  tags: string; // comma-separated tags
  care_instructions: string;
  usage_guidelines: string;
}

async function callGemini(prompt: string): Promise<string> {
  if (!GEMINI_API_KEY) {
    throw new Error('VITE_GEMINI_API_KEY is not configured');
  }

  const response = await fetch(`${API_URL}?key=${GEMINI_API_KEY}`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      contents: [{
        parts: [{ text: prompt }],
      }],
    }),
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    console.error('Gemini API error:', errorData);
    throw new Error(
      `Gemini API error: ${errorData.error?.message || response.statusText || 'Unknown error'}`,
    );
  }

  const data = await response.json();
  const generatedText: string | undefined = data.candidates?.[0]?.content?.parts?.[0]?.text;

  if (!generatedText) {
    throw new Error('No content generated by Gemini API');
  }

  return generatedText;
}

/**
 * Generate structured product copy (name, description, features, specs, tags, care, usage)
 * for the admin product dialogs.
 */
export async function generateProductCopy(request: ProductCopyRequest): Promise<ProductCopyResult> {
  const tone = request.tone || 'playful';
  const prompt = `
You are helping an ecommerce admin write product details.

Generate a single JSON object for a product based on this context:
- Name: ${request.name || '(none provided)'}
- Category: ${request.category || '(unspecified)'}
- Extra keywords or notes: ${request.keywords || '(none)'}
- Tone: ${tone}

Return ONLY valid JSON with these exact keys:
{
  "name": string,
  "description": string,
  "features": string,          // bullet points separated by \n
  "specifications": string,    // bullet points separated by \n
  "tags": string,              // comma-separated keywords
  "care_instructions": string,
  "usage_guidelines": string
}

Constraints:
- Keep description under 120 words.
- Use friendly, clear language.
- Do not include markdown formatting.
- Do not include backticks or code fences.
- Do not explain what you are doing.
`;

  const raw = await callGemini(prompt);

  // Attempt to parse JSON from the model output
  let jsonText = raw.trim();
  // Strip accidental code fences if present
  if (jsonText.startsWith('```')) {
    jsonText = jsonText.replace(/^```[a-zA-Z]*\n?/, '').replace(/```$/, '').trim();
  }

  try {
    const parsed = JSON.parse(jsonText) as Partial<ProductCopyResult>;
    return {
      name: parsed.name || request.name || 'New Product',
      description: parsed.description || '',
      features: parsed.features || '',
      specifications: parsed.specifications || '',
      tags: parsed.tags || '',
      care_instructions: parsed.care_instructions || '',
      usage_guidelines: parsed.usage_guidelines || '',
    };
  } catch (e) {
    console.error('Failed to parse Gemini product copy JSON, returning raw text', e, raw);
    // Fallback: use raw text as description
    return {
      name: request.name || 'New Product',
      description: raw.trim(),
      features: '',
      specifications: '',
      tags: '',
      care_instructions: '',
      usage_guidelines: '',
    };
  }
}

/**
 * Generate WhatsApp template content using Gemini AI
 * @param templateType The type of template to generate (e.g., order_confirmation)
 * @param description Brief description of the template's purpose
 * @returns Generated template content
 */
export async function generateTemplateContent(
  templateType: string,
  description: string
): Promise<string> {
  try {
    // List of available variables for templates
    const availableVariables = [
      'customerName', 'orderId', 'amount', 'retryUrl', 'carrier',
      'trackingLink', 'estimatedDelivery', 'feedbackLink', 'reviewLink',
      'refundAmount', 'daysSinceDelivery', 'reorderLink', 'cartUrl'
    ];

    // Construct the prompt for Gemini
    const prompt = `
      Create a short WhatsApp message template for a business CRM system. The template type is: ${templateType}.
      
      Template purpose: ${description}
      
      IMPORTANT FORMATTING INSTRUCTIONS:
      1. Start with 1-2 relevant emojis followed by a *bold title*
      2. Use line breaks (\n) between paragraphs
      3. Keep the message under 500 characters total
      4. Format key information with *asterisks* to make it bold in WhatsApp
      5. Use a friendly, professional tone
      6. Include a clear call-to-action if relevant
      7. DO NOT include any explanations or comments about the template
      8. ONLY return the template text itself
      
      AVAILABLE VARIABLES (use exactly as shown):
      ${availableVariables.map(v => `- {{${v}}}`).join('\n')}
      
      For the template "${templateType}", be sure to include the most relevant variables from the list above.
      
      EXAMPLE FORMAT (for a different template type):
      ðŸŽ‰ *Order Confirmed* ðŸŽ‰\n\nHi {{customerName}},\n\nYour order #{{orderId}} has been confirmed!\n\nThank you for shopping with us.\n\nWe'll update you when your order ships.
    `;

    const generatedText = await callGemini(prompt);

    // Clean up the response to extract just the template content
    const cleanedText = generatedText.replace(/```[\s\S]*?```/g, '');

    return cleanedText.trim();
  } catch (error) {
    console.error('Error generating template with Gemini:', error);
    const err = error as any;
    throw new Error(`Failed to generate template: ${err?.message || 'Unknown error'}`);
  }
}

/**
 * Generate a description for a WhatsApp template
 * @param templateType The type of template
 * @returns Generated description
 */
export async function generateTemplateDescription(templateType: string): Promise<string> {
  try {
    const prompt = `Write a brief one-sentence description (maximum 100 characters) for a WhatsApp message template of type "${templateType}". The description should explain when this template would be sent to customers.`;

    const generatedText = await callGemini(prompt);
    return generatedText.trim();
  } catch (error) {
    console.error('Error generating template description with Gemini:', error);
    return `Template for ${templateType.replace(/_/g, ' ').toLowerCase()}`;
  }
}

/**
 * Generate Puck (page builder) content for the visual editor.
 * Supports two modes:
 * - "page": returns a full page payload { root, content[] }
 * - "section": returns an array of blocks to insert below the current selection
 */
export async function generatePuckContent(
  request: PuckAiRequest,
): Promise<PuckAiPageData | PuckAiBlock[]> {
  const tone = request.tone || 'playful';

  // Build product context snippet for the prompt if provided
  const product = request.product;
  const productContext = product
    ? `Product context:
- ID: ${product.id}
- Name: ${product.name || '(unknown)'}
- Category: ${product.category || '(unknown)'}
- Price: ${
        typeof product.price === 'number' && Number.isFinite(product.price)
          ? product.price
          : '(unknown)'
      }
- Tags: ${(() => {
        const raw = product.tags;
        if (Array.isArray(raw)) return raw.join(', ');
        if (typeof raw === 'string') return raw;
        if (raw == null) return '(none)';
        try {
          return JSON.stringify(raw);
        } catch {
          return String(raw);
        }
      })()}
- Description: ${(product.description || '(none)').slice(0, 400)}
`
    : 'No specific product context.';

  const modeLabel = request.mode === 'page' ? 'FULL PAGE' : 'SINGLE SECTION';

  let prompt = `You are helping an ecommerce admin build React page layouts using the Puck visual editor for a storefront.

Generation mode: ${modeLabel}
Requested description: ${request.description}
Tone: ${tone}

${productContext}

The site uses a library of reusable layout components. Prefer these component types when appropriate:
- Hero, InteractiveHero, OfferBanner
- FeatureSection, CardGrid, Grid, Magazine, Asymmetrical, ZShape, FShape
- ProductGrid, CategorySection, CollectionsCarousel, FeaturedMedia, BrandShowcase
- NewsletterSection, TestimonialSection, Text, Button, Spacer, TwoColumn, SplitScreen, Container

General rules:
- Use realistic but concise marketing copy.
- Use short headings and 1â€“3 line body text.
- Do NOT include markdown, backticks, code fences, or comments.
- Do NOT explain what you are doing.
`;

  if (request.mode === 'page') {
    prompt += `
Return ONLY valid JSON in this exact shape:

{
  "root": {
    "title": string,            // short page title
    "description"?: string      // optional meta description
  },
  "content": [
    {
      "type": string,           // one of the component types listed above
      "props": { ... }          // props for that component
    }
  ]
}

- root is required and must be an object (use {} if you have no metadata).
- content MUST be a non-empty array.
- props must be plain JSON data (no functions).
`;
  } else {
    prompt += `
Return ONLY valid JSON in this exact shape:

[
  {
    "type": string,
    "props": { ... }
  }
]

- This is a list of 1â€“4 blocks to insert below the current selection.
- Each type should be one of the component types listed above.
- props must be plain JSON data (no functions).
`;
  }

  const raw = await callGemini(prompt);

  // Normalise output by stripping accidental code fences
  let jsonText = raw.trim();
  if (jsonText.startsWith('```')) {
    jsonText = jsonText
      .replace(/^```[a-zA-Z]*\n?/, '')
      .replace(/```$/, '')
      .trim();
  }

  try {
    const parsed = JSON.parse(jsonText);

    if (request.mode === 'page') {
      const page = parsed as Partial<PuckAiPageData>;
      const contentArr = Array.isArray(page.content) ? page.content : [];
      return {
        root:
          page.root && typeof page.root === 'object' && !Array.isArray(page.root)
            ? page.root
            : {},
        content: contentArr as PuckAiBlock[],
      };
    }

    // section mode
    if (Array.isArray(parsed)) {
      return parsed as PuckAiBlock[];
    }
    if (parsed && Array.isArray((parsed as any).content)) {
      return (parsed as any).content as PuckAiBlock[];
    }
  } catch (err) {
    console.error('Failed to parse Gemini Puck content JSON, falling back to Text block', err, raw);
  }

  // Fallbacks: wrap raw text in a simple Text block
  if (request.mode === 'page') {
    return {
      root: { title: request.description.slice(0, 60) || 'Generated Page' },
      content: [
        {
          type: 'Text',
          props: { text: raw.trim() || request.description },
        },
      ],
    };
  }

  return [
    {
      type: 'Text',
      props: { text: raw.trim() || request.description },
    },
  ];
}
